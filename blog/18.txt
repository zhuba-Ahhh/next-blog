3:I[33385,[],""]
5:I[46855,[],""]
6:I[85327,["786","static/chunks/786-f16eb86c36ff5927.js","185","static/chunks/app/layout-353c8a325dc15d80.js"],"ViewTransitions"]
7:I[1455,["786","static/chunks/786-f16eb86c36ff5927.js","185","static/chunks/app/layout-353c8a325dc15d80.js"],"ThemeProvider"]
8:I[9844,["786","static/chunks/786-f16eb86c36ff5927.js","185","static/chunks/app/layout-353c8a325dc15d80.js"],"default"]
9:I[8105,["786","static/chunks/786-f16eb86c36ff5927.js","185","static/chunks/app/layout-353c8a325dc15d80.js"],"default"]
a:I[85327,["786","static/chunks/786-f16eb86c36ff5927.js","185","static/chunks/app/layout-353c8a325dc15d80.js"],"Link"]
4:["id","18","d"]
0:["XNMB7XJ-Fsc-PiJjQoQ0u",[[["",{"children":["blog",{"children":[["id","18","d"],{"children":["__PAGE__?{\"id\":\"18\"}",{}]}]}]},"$undefined","$undefined",true],["",{"children":["blog",{"children":[["id","18","d"],{"children":["__PAGE__",{},[["$L1","$L2",null],null],null]},[null,["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children","blog","children","$4","children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L5",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined"}]],null]},[null,["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children","blog","children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L5",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined"}]],null]},[[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/4b751e17faaae912.css","precedence":"next","crossOrigin":"$undefined"}],["$","link","1",{"rel":"stylesheet","href":"/_next/static/css/b9e5f75db2a40d89.css","precedence":"next","crossOrigin":"$undefined"}],["$","link","2",{"rel":"stylesheet","href":"/_next/static/css/93c09f23e5e79b42.css","precedence":"next","crossOrigin":"$undefined"}],["$","link","3",{"rel":"stylesheet","href":"/_next/static/css/d95f70565c8fec8b.css","precedence":"next","crossOrigin":"$undefined"}],["$","link","4",{"rel":"stylesheet","href":"/_next/static/css/15a4a72a41cadd99.css","precedence":"next","crossOrigin":"$undefined"}],["$","link","5",{"rel":"stylesheet","href":"/_next/static/css/5e92f1bdc02d74d7.css","precedence":"next","crossOrigin":"$undefined"}],["$","link","6",{"rel":"stylesheet","href":"/_next/static/css/d5f776ab7d52433a.css","precedence":"next","crossOrigin":"$undefined"}]],["$","$L6",null,{"children":["$","html",null,{"lang":"zh","suppressHydrationWarning":true,"className":"h-full","children":[["$","head",null,{"children":[["$","link",null,{"rel":"icon","href":"/next.svg","type":"image/svg+xml"}],["$","link",null,{"rel":"stylesheet","href":"https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"}],["$","script",null,{"src":"https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js","defer":true}],["$","script",null,{"src":"https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js","defer":true}]]}],["$","body",null,{"className":"flex flex-col bg-background antialiased h-full","children":["$","$L7",null,{"attribute":"class","children":[["$","$L8",null,{}],["$","$L9",null,{"children":["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L5",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":[["$","title",null,{"children":"404: This page could not be found."}],["$","div",null,{"style":{"fontFamily":"system-ui,\"Segoe UI\",Roboto,Helvetica,Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\"","height":"100vh","textAlign":"center","display":"flex","flexDirection":"column","alignItems":"center","justifyContent":"center"},"children":["$","div",null,{"children":[["$","style",null,{"dangerouslySetInnerHTML":{"__html":"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}"}}],["$","h1",null,{"className":"next-error-h1","style":{"display":"inline-block","margin":"0 20px 0 0","padding":"0 23px 0 0","fontSize":24,"fontWeight":500,"verticalAlign":"top","lineHeight":"49px"},"children":"404"}],["$","div",null,{"style":{"display":"inline-block"},"children":["$","h2",null,{"style":{"fontSize":14,"fontWeight":400,"lineHeight":"49px","margin":0},"children":"This page could not be found."}]}]]}]}]],"notFoundStyles":[]}]}],["$","footer",null,{"className":"border-t py-6 md:py-0 bg-background","children":["$","div",null,{"className":"container flex flex-col items-center justify-between gap-4 md:h-24 md:flex-row","children":[["$","div",null,{"className":"flex flex-col items-center gap-4 px-8 md:flex-row md:gap-2 md:px-0","children":["$","p",null,{"className":"text-center text-sm leading-loose text-muted-foreground md:text-left","children":["© ",2025," 我的博客. 保留所有权利。","建站时间: 2024年","，感谢您的访问！"]}]}],["$","nav",null,{"className":"flex items-center space-x-4","children":[["$","$La","/privacy",{"href":"/privacy","className":"text-sm text-muted-foreground hover:text-primary transition duration-200","children":["$","div",null,{"className":"inline-flex items-center rounded-full border px-2.5 py-0.5 text-xs font-semibold focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 cursor-pointer transition-transform duration-200 ease-in-out hover:scale-105 active:scale-95 text-foreground hover:bg-accent hover:text-accent-foreground active:bg-accent/90","children":"隐私政策"}]}],["$","$La","/terms",{"href":"/terms","className":"text-sm text-muted-foreground hover:text-primary transition duration-200","children":["$","div",null,{"className":"inline-flex items-center rounded-full border px-2.5 py-0.5 text-xs font-semibold focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 cursor-pointer transition-transform duration-200 ease-in-out hover:scale-105 active:scale-95 text-foreground hover:bg-accent hover:text-accent-foreground active:bg-accent/90","children":"使用条款"}]}],["$","$La","/contact",{"href":"/contact","className":"text-sm text-muted-foreground hover:text-primary transition duration-200","children":["$","div",null,{"className":"inline-flex items-center rounded-full border px-2.5 py-0.5 text-xs font-semibold focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 cursor-pointer transition-transform duration-200 ease-in-out hover:scale-105 active:scale-95 text-foreground hover:bg-accent hover:text-accent-foreground active:bg-accent/90","children":"联系我们"}]}]]}]]}]}]]}]}]]}]}]],null],null],["$Lb",null]]]]
c:I[52980,["14","static/chunks/ca9a4ea3-e6fe29553acd31c9.js","226","static/chunks/102969c4-c00103e5fa46735b.js","278","static/chunks/64d1c0c4-9cbf5a1783dc4bcc.js","786","static/chunks/786-f16eb86c36ff5927.js","566","static/chunks/566-af6dbde16cc76949.js","558","static/chunks/558-573f295bffeef894.js","353","static/chunks/353-a2d9ae56abaca03c.js","548","static/chunks/app/blog/%5Bid%5D/page-a368bd32e117e6b1.js"],"default"]
d:"$Sreact.suspense"
e:I[72925,["14","static/chunks/ca9a4ea3-e6fe29553acd31c9.js","226","static/chunks/102969c4-c00103e5fa46735b.js","278","static/chunks/64d1c0c4-9cbf5a1783dc4bcc.js","786","static/chunks/786-f16eb86c36ff5927.js","566","static/chunks/566-af6dbde16cc76949.js","558","static/chunks/558-573f295bffeef894.js","353","static/chunks/353-a2d9ae56abaca03c.js","548","static/chunks/app/blog/%5Bid%5D/page-a368bd32e117e6b1.js"],"BailoutToCSR"]
f:I[68979,["14","static/chunks/ca9a4ea3-e6fe29553acd31c9.js","226","static/chunks/102969c4-c00103e5fa46735b.js","278","static/chunks/64d1c0c4-9cbf5a1783dc4bcc.js","786","static/chunks/786-f16eb86c36ff5927.js","566","static/chunks/566-af6dbde16cc76949.js","558","static/chunks/558-573f295bffeef894.js","353","static/chunks/353-a2d9ae56abaca03c.js","548","static/chunks/app/blog/%5Bid%5D/page-a368bd32e117e6b1.js"],"default"]
10:T539,
## 情况

使用`@nestjs/swagger`撰写api文档，本地打包预览正常，上传部署报错:
`swagger-ui.css`等资源缺失

![](https://p0-xtjj-private.juejin.cn/tos-cn-i-73owjymdk6/d55bf5102a524a9f96280f559d9b3af1~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bGx6Z2S6Iqx5qyy54eDMzEw:q75.awebp?policy=eyJ2bSI6MywidWlkIjoiMzcwMzYyMDA3ODY3OTY3MSJ9&rk3s=f64ab15b&x-orig-authkey=f32326d3454f2ac7e96d3d06cdbb035152127018&x-orig-expires=1734666281&x-orig-sign=QM0Dm%2FUPU1S2Y%2Bi3rYwfbzqht1E%3D)

## 解法

使用`customCssUrl`和`customJs`动态注入资源

```ts
const CSS_URL = [
  'https://cdnjs.cloudflare.com/ajax/libs/swagger-ui/5.18.2/swagger-ui.min.css',
];

const JS_URL = [
  'https://cdnjs.cloudflare.com/ajax/libs/swagger-ui/5.18.2/swagger-ui.min.js',
  'https://cdnjs.cloudflare.com/ajax/libs/swagger-ui/5.18.2/swagger-ui-bundle.min.js',
  'https://cdnjs.cloudflare.com/ajax/libs/swagger-ui/5.18.2/swagger-ui-standalone-preset.min.js',
];


SwaggerModule.setup('doc', app, document, {
    jsonDocumentUrl: 'doc/json',
    customCssUrl: CSS_URL,
    customJs: JS_URL,
  });
```

缺点：

1.  依旧会报错
2.  页面会出来慢一点

有其他解决方案可以分享交流下~

参考： [Documentation | NestJS - A progressive Node.js framework](https://docs.nestjs.com/openapi/introduction)
11:T21de,# React 实现流式接口对接：打造实时响应的 AI 对话体验

在现代 AI 对话应用中，流式响应（Streaming Response）已经成为提升用户体验的关键技术。本文将详细介绍如何在 React 应用中实现流式接口的对接。

## 一、流式接口的基本概念

流式接口允许服务器以流的形式持续发送数据，而不是等待所有数据准备就绪后一次性返回。在 AI 对话场景中，这意味着用户可以实时看到 AI 的回复，而不是等待完整回复后才能看到内容。

## 二、技术实现

### 1. 服务端请求实现

```typescript
const response = await fetch('/api/stream', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
    'Accept': 'text/event-stream',
  },
  cache: 'no-store',
  keepalive: true,
  body: JSON.stringify(payload)
});

const reader = response.body?.getReader();
const decoder = new TextDecoder();
```

关键点：
- 使用 `fetch` API 发起请求
- 设置 `Accept: text/event-stream` 头部
- 使用 `ReadableStream` 读取流数据
- 通过 `TextDecoder` 解码二进制数据

### 2. 数据处理与解析

```typescript
while (reader) {
  const { done, value } = await reader.read();
  if (done) break;
  
  const chunk = decoder.decode(value, { stream: true });
  const lines = chunk.split('
').filter(line => line.trim());
  
  for (const line of lines) {
    if (line.startsWith('data:')) {
      const jsonStr = line.replace(/^data:/, '').trim();
      const message = JSON.parse(jsonStr);
      // 处理消息
    }
  }
}
```

关键点：
- 循环读取流数据
- 按行解析数据
- 处理 SSE（Server-Sent Events）格式
- JSON 解析与错误处理

### 3. React 状态更新

由于后端返回的分片长度可能不一(网关、AP、协议等原因)以及React短时间多次更新状态会合并成成一次更新，所以需要前端自己兼容实现稳定的输出

```typescript
const [messages, setMessages] = useState<Message[]>([]);

const handleNewContent = (content: string) => {
  flushSync(() => {
    setMessages(oldMessages => {
      const newMessages = [...oldMessages];
      newMessages[newMessages.length - 1] = {
        ...newMessages[newMessages.length - 1],
        content: newMessages[newMessages.length - 1].content + content
      };
      return newMessages;
    });
  });
};
```

关键点：
- 使用 `useState` 管理消息状态
- 使用 `flushSync` 确保状态更新的同步性
- 增量更新消息内容

### 4. 打字机效果实现

```typescript
const chars = content.split('');
await Promise.all(
  chars.map((char, index) =>
    new Promise(resolve =>
      setTimeout(() => {
        onNewMsg(char);
        resolve(null);
      }, index * 50)
    )
  )
);
```

关键点：
- 字符分割
- 使用 `Promise.all` 和 `setTimeout` 实现打字效果
- 可配置的打字速度

## 三、错误处理与中断控制

```typescript
try {
  if (options.abortSignal?.aborted) {
    reader.cancel();
    return false;
  }
  // ... 处理逻辑
} catch (error) {
  console.error('Stream error:', error);
  return { content: '请求失败', isError: true };
}
```

关键点：
- 支持请求中断
- 错误状态处理
- 用户友好的错误提示

## 四、性能优化

1. **批量更新**：使用 `flushSync` 确保状态更新的及时性
2. **防抖处理**：对频繁的状态更新进行控制
3. **内存管理**：及时清理不需要的数据和监听器

## 五、用户体验提升

1. **加载状态**：显示打字机效果
2. **错误处理**：友好的错误提示
3. **实时反馈**：即时显示接收到的内容

## 总结

实现流式接口不仅需要考虑技术实现，还要注重用户体验。通过合理的状态管理、错误处理和性能优化，可以打造出流畅的 AI 对话体验。

关键代码可参考：
- 请求：
```ts
export type AIStreamResponse = {
  content: string;
  hasDone: boolean;
  isError: boolean;
};

export const postAIStream = async (
  options: {
    messages: AIMessage[];
    abortSignal?: AbortSignal; // 新增可中断信号
  },
  onNewMsg: (msg: string) => void,
  model: string,
  operator: string,
): Promise<AIStreamResponse | false> => {
  // 检查是否中断
  if (options.abortSignal?.aborted) {
    return false;
  }
  // 新增 usage 变量
  let usage: any = {};
  // 将原来的 Modal.confirm 替换为统一函数 showRetryConfirm

  try {
    const response = await fetch('/model/service/stream', {
      method: 'POST',
      credentials: 'include',
      headers: {
        'Content-Type': 'application/json',
        Accept: 'text/event-stream',
      },
      // 添加HTTP/2相关配置
      cache: 'no-store',
      keepalive: true,
      body: JSON.stringify({
        operator,
        model,
        messages: options.messages,
        stream: true,
      }),
    });

    const reader = response.body?.getReader();
    const decoder = new TextDecoder();

    let hasDone = false;
    let content = '';
    let incompleteLine = ''; // 存储不完整的行

    while (reader) {
      // 检查中断信号
      if (options.abortSignal?.aborted) {
        reader.cancel();
        return false;
      }
      const { done, value } = await reader.read();
      if (done) {
        break;
      }

      const chunk = decoder.decode(value, { stream: true });

      // 将上一个不完整的行与当前chunk拼接
      const textToProcess = incompleteLine + chunk;
      incompleteLine = '';

      // 按行分割，但保持事件标记完整
      const lines = textToProcess
        .split(/
/)
        .map((line) => line.trim())
        .filter((line) => line);

      for (let i = 0; i < lines.length; i++) {
        const line = lines[i];
        // 标记正常结束
        if (line.includes(`event:done`)) {
          hasDone = true;
        }

        // 如果是最后一行且chunk没有以换行符结束，认为可能是不完整的
        if (i === lines.length - 1 && !chunk.endsWith('
')) {
          incompleteLine = line;
          continue;
        }

        if (line.startsWith('data:')) {
          try {
            const jsonStr = line.replace(/^data:/, '').trim();
            // 确保不处理空字符串
            if (!jsonStr) continue;

            const message = JSON.parse(jsonStr);
            // 新增：处理 usage 字段
            if (message.data && message.data.usage) {
              usage = message.data.usage;
            }

            if (!message.finish && message.data?.choices?.[0]?.message?.content) {
              const currentContent = message.data.choices[0].message.content;
              // 按字符分割当前内容
              const chars = currentContent.split('');
              // 使用 Promise.all 和 setTimeout 实现均匀的打字效果
              await Promise.all(
                chars.map(
                  (char: string, index: number) =>
                    new Promise(
                      (resolve) =>
                        setTimeout(() => {
                          onNewMsg(char);
                          resolve(null);
                        }, index * 50), // 每个字符之间间隔 50ms
                    ),
                ),
              );
              content += currentContent;
            }
          } catch (e) {
            console.warn('Parse error, might be incomplete JSON:', line);
            // 如果不是最后一行却解析失败，记录错误
            if (i < lines.length - 1) {
              console.error('JSON parse error in middle of chunk:', e);
            }
            continue;
          }
        }
      }
    }
    // 结束时返回 content 和 usage
    if (hasDone) {
      return { content, usage, hasDone, isError: false };
    }
    return { content: '大模型调用失败', usage, hasDone: true, isError: true };
  } catch (error) {
    console.error('Stream error:', error);
    return { content: '大模型调用失败', usage, hasDone: true, isError: true };
  }
};
```

- 调用
```ts
    const res = await postAIStream(
      {
        messages: [newMessages],
      },
      (content) => {
        flushSync(() =>
          setMessages((oldMessage) => {
            const messages = [...oldMessage];
            messages[messages.length - 1] = {
              content: messages[messages.length - 1].content + content,
              role: 'assistant',
            };

            return messages;
          }),
        );
        if (!isStart) {
          isStart = true;
        }
      },
      currentModel,
      userInfo?.username,
    ).finally(() => {
      setLoading(false);
    });
```2:[["$","$Lc",null,{}],["$","$d",null,{"fallback":null,"children":["$","$Le",null,{"reason":"next/dynamic","children":["$","$Lf",null,{"post":{"id":18,"title":"@nestjs/swagger部署报错","excerpt":"@nestjs/swagger撰写api文档...","content":"$10","date":"2024-12-10","author":"李十八","tags":["nestjs","nodejs"]},"headings":[{"level":2,"text":"情况","slug":"情况"},{"level":2,"text":"解法","slug":"解法"}],"readingTime":1,"wordCount":52,"relatedPosts":[],"prevPost":{"id":16,"title":"Serverless架构与前端开发","excerpt":"探讨Serverless架构如何简化前端开发流程...","content":"Serverless架构是一种新兴的云计算模式，允许开发者专注于代码而无需管理服务器。通过使用云服务提供商（如AWS Lambda、Azure Functions等），前端开发者可以快速构建和部署应用程序。Serverless架构的优势包括自动扩展、按需计费和简化的运维管理。本文将深入探讨如何在前端项目中有效利用Serverless架构。\n\n## 什么是Serverless架构？\n\nServerless架构并不意味着没有服务器，而是将服务器的管理和维护工作交给云服务提供商。开发者只需编写代码并上传到云平台，云服务提供商会负责运行、扩展和维护这些代码。\n\n## Serverless架构的优势\n\n1. **自动扩展**：根据流量自动调整资源，确保应用在高负载时依然稳定。\n2. **按需计费**：只为实际使用的计算资源付费，降低了成本。\n3. **简化运维**：减少了服务器管理的复杂性，开发者可以将更多精力放在业务逻辑上。\n\n## 如何在前端项目中使用Serverless架构\n\n### 1. 选择合适的云服务提供商\n\n选择一个支持Serverless架构的云服务提供商，如AWS、Azure或Google Cloud。了解它们的功能、定价和支持的编程语言。\n\n### 2. 设计无状态的函数\n\nServerless函数应设计为无状态的，确保每次调用都是独立的。可以使用外部存储（如数据库或缓存）来管理状态。\n\n### 3. 使用API Gateway\n\n通过API Gateway将前端请求路由到Serverless函数。API Gateway可以处理身份验证、流量管理和监控等功能。\n\n### 4. 监控和调试\n\n使用云服务提供商提供的监控工具，跟踪函数的性能和错误。确保能够快速定位和解决问题。\n\n## 结论\n\nServerless架构为前端开发者提供了一个高效、灵活的开发模式。通过合理利用Serverless架构，开发者可以专注于业务逻辑，提升开发效率和应用性能。随着技术的不断发展，Serverless架构将会在前端开发中扮演越来越重要的角色。","date":"2024-05-30","author":"李十八","tags":["Serverless","前端开发","云计算"]},"nextPost":{"id":19,"title":"React 实现流式接口对接：打造实时响应的 AI 对话体验","excerpt":"流式接口显著改善大模型的用户体验。","content":"$11","date":"2025-04-01","author":"陈十久","tags":["React","Hooks","前端开发"]}}]}]}]]
b:[["$","meta","0",{"name":"viewport","content":"width=device-width, initial-scale=1"}],["$","meta","1",{"charSet":"utf-8"}],["$","title","2",{"children":"我的博客"}],["$","meta","3",{"name":"description","content":"欢迎来到我的博客,这里分享前端开发的最新趋势和技巧"}],["$","meta","4",{"name":"keywords","content":"Next.js,React,JavaScript,前端开发"}],["$","meta","5",{"property":"og:title","content":"我的博客"}],["$","meta","6",{"property":"og:description","content":"欢迎来到我的博客,这里分享前端开发的最新趋势和技巧"}],["$","meta","7",{"property":"og:url","content":"https://yourblog.com"}],["$","meta","8",{"property":"og:locale","content":"zh_CN"}],["$","meta","9",{"property":"og:type","content":"website"}],["$","meta","10",{"name":"twitter:card","content":"summary"}],["$","meta","11",{"name":"twitter:title","content":"我的博客"}],["$","meta","12",{"name":"twitter:description","content":"欢迎来到我的博客,这里分享前端开发的最新趋势和技巧"}]]
1:null
